## 컴퓨터 구조

#### Computer-System Architecture
- system bus: PCI bus(Peripheral Component Interconnect Bus)는 컴퓨터 메인보드에 주변 장치를 장착하는 데 쓰이는 컴퓨터 버스의 일종이다.
- PCI 프로토콜: 예) O번~O번까지는 OO버스로 사용하자는 약속
- 프로토콜을 정해두는 이유? 표준이 정해져 있어야 디바이스를 만드는 사람들이 정해진 규칙대로 만들 수 있다.
- 부모 CPU가 데이터와 명령어를 active device에 전달하면, 컨트롤러의 자식 CPU가 받아 수행한다.
  (메모리, 장치들: passive device/ 컨트롤러: active device)
  
#### 컴퓨터 시스템 운영
- I/O 장치와 CPU가 동시에 실행될 수 있다.
- 각 장치 컨트롤러는 특정 장치 유형을 담당한다.
- 각 장치 컨트롤러에는 로컬 버퍼(커널 속)가 있다. 
- CPU는 데이터를 메인메모리에서 로컬 버퍼를 거쳐 이동한다.
- I/O는 장치에서 컨트롤러 로컬 버퍼까지이다.
- 장치 컨트롤러는 CPU에 인터럽트를 일으켜 작동을 마쳤다고 알려준다.
  (인터럽트: 유저가 디스크에 파일을 읽으라고 명령하여 버퍼 포인트에 넣으라고 명령한 후, 디바이스가 일이 끝이 났을 때 알려주는 것)

#### 인터럽트의 공통 기능
- 일반적으로 인터럽트 벡터 테이블(모든 서비스 루틴의 주소)을 통해, 인터럽트 서비스 루틴으로 제어권을 넘긴다.
  인터럽트 서비스 루틴의 예) 키보드에서 n을 누르면 신호가 들어감 → 인터럽트 벡터 테이블에 5번으로 감 → 해당하는 주소 5000번지로 이동 → 처리해야 할 작업 실행
- 인터럽트 아키텍처는 인터럽트 된 명령의 주소를 저장해야 한다.
- 동시에 인터럽트가 발생하는 경우 하나의 인터럽트가 끝날 때까지 다른 하나의 인터럽트가 손실될 것을 방지하기 위해 비활성화된다.
- Trap은 오류나 사용자 요청에 의해 발생하는 소프트웨어 생성 인터럽트다.
- 운영체제는 인터럽트 구동된다.

#### System-call은 Signal, device-call은 interrupt
- 커널 안에 3개의 active process가 돌아감: process id = 0(스케줄러), 1(swap), 2(pager) 나머지는 passive code
    

#### 인터럽트 핸들링
- 운영 체제는 레지스터와 프로그램 카운터를 저장하여 CPU의 상태를 보존한다.
- 발생한 인터럽트 유형 결정
  Polling: 장치 또는 프로그램의 충돌, 회피, 동기화 처리 등을 목적으로 다른 장치 또는 프로그램을 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식
  Vectored 인터럽트 시스템: 인터럽트 서비스 루틴에 주소가 있고, 특정 장소로 점프하도록 구성 (多)
- 단일 프로세스 출력 수행에 대한 인터럽트 타임라인
  
- CPU가 디바이스에게 일을 시킬 때, 2개의 레지스터를 사용한다. (control 레지스터, status 레지스터)
  1) CPU가 status 레지스터를 읽고, 바쁜지 아닌지 체크 한다. 바쁘면 polling을 하며 기다린다.
  2) 바쁘지 않은 상태면 control 레지스터에게 명령어를 주면 그에 따라 디바이스가 일을 한다.

#### I/O 구조
  1) Synchronous I/O: I/O 시작된 후, 컨트롤이 완료 시에만 유저 프로그램으로 복귀
  - 하드웨어가 일을 할 때까지 유저 프로세스가 기다림, 끝나면 돌아옴, I/O 동작과 유저 프로세스 동작이 동시 병렬로 이루어지지 않음, 동기적으로 이루어짐)
  2) Asynchronous I/O: I/O가 시작된 후, 완료를 기다리지 않고 컨트롤이 유저 프로그램으로 복귀
  - I/O에게 동작을 시켜놓고 유저 프로세스로 돌아와서 각자 실행함, 동시 병렬로 이루어짐, 빠르고 효과적임
  
#### 직접 메모리 엑세스(DMA) 구조 
- 메모리와 I/O 사이에 DMA를 두고 사용하는 방식
- 메모리 속도에 가까운 속도로 정보를 전송할 수 있는 고속 I/O 장치에 사용
- 장치 컨트롤러는 CPU 개입 없이 버퍼 저장 공간에서 메인 메모리로 데이터를 전송
- Byte 단위로 하나의 인터럽트가 아닌 블록(64kbyte) 당 인터럽트만 생성

#### 저장 구조
- 메인 메모리: CPU가 직접 엑세스 할 수 있는 단 하나의 대용량 저장 미디어
- 보조 저장공간(하드디스크): 대용량 비휘발성 저장 용량을 제공하는 메인 메모리의 확장
- 자기 디스크: 자기 기록 재료로 덮인 단단한 금속 또는 유리 원반
  디스크 표면은 트랙으로 논리적으로 구분되며, 트랙은 섹터로 세분된다.
  디스크 컨트롤러는 장치와 컴퓨터 사이의 논리적 상호작용을 결정한다.
- Moving-Head Disk Mechanism
  
#### 저장 체계
- 계층 구조로 구성된 저장 시스템: 속도/ 비용/ 휘발성
- 레지스터(CPU), cache, main memory(primary), secondary- 
  

#### Caching(고속 기억장치)
- 가장 최근의 데이터를 저장하고 있다. Locality of Reference
- 캐시 관리 정책 필요
- 캐싱은 저장 계층의 또 다른 수준을 도입한다. 이를 위해서는 하나 이상의 레벨에 동시에 저장되는 데이터가 필요하다. Consistent!
- 정보를 더 빠른 저장 시스템으로 복사, 메인 메모리는 보조기억장치의 마지막 캐시로 볼 수 있다.

∙디스크에서 레지스터로 이송
- Read
  

#### 하드웨어 보호
  1) 듀얼모드 운영
  - 시스템 자원을 공유하려면 운영 체제가 잘못된 프로그램을 통해 다른 프로그램이 잘못 실행되지 않도록 해야 한다. (유저모드 -(system call)- 커널모드(=시스템모드)) 
  - 최소 두 가지 작동 모드를 구별할 수 있는 하드웨어 지원 제공
    (유저모드, 모니터모드(커널모드(=시스템모드)))
  - 인터럽트 또는 고장이 발생하면 하드웨어가 모니터 모드로 전환된다.
  - 권한 있는 명령은 모니터 모드에서만 발급될 수 있다.
  2) I/O 보호
  - 모든 I/O 명령은 권한 있는 명령이다.
  - 사용자 프로그램이 모니터 모드에서 컴퓨터의 제어를 절대 얻을 수 없도록 해야한다.
  - 시스템 호출을 사용하여 I/O 수행
    
  3) 메모리 보호
  - 인터럽트 벡터 및 인터럽트 서비스 루틴에 대해 최소한 메모리 보호를 제공 해야한다.
  - 메모리 보호를 위해, 프로그램이 엑세스 할 수 있는 2개의 레지스터를 추가
    Base 레지스터(가장 작은 합법 물리적 메모리 주소를 보유), Limit 레지스터(범위의 크기 포함)
  - 정의된 범위를 벗어나는 메모리는 보호된다.
  4) 하드웨어 주소 보호
  - 모니터 모드에서 실행될 때 운영체제는 모니터와 사용자의 메모리에 부제한으로 엑세스 할 수 있다.
  - 기본 및 제한 레지스터에 대한 load 명령은 권한 있는 명령이다.
    
  5) CPU 보호
  - 타이머: 운영 체제가 제어권을 유지하도록 지정된 기간 후에 컴퓨터를 중단
    타이머는 모든 Clock 눈금에서 감소
    타이머가 값 0에 도달하면, 인터러브가 발생
  - 시간 공유를 구현하는데 일반적으로 사용되는 타이머
  - 또한 현재 시간을 계산하는데 사용되는 타이머
  - Load-timer는 권한 있는 명령이다.
  
#### 네트워크 구조
- LAN: Local Area Network
- WAN: Wide Area Network
